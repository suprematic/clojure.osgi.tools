(ns clojure.osgi.tools.bnd
	(require 
		[clojure.tools.logging :as log]
		[clojure.java.io :as io]
		[clojure.xml :as xml]))


(def RE_VERSION #"((\d+)\.(\d+).(\d+)).*")

(defn- trim-build-segment [version]
	(get (re-matches RE_VERSION version) 1))

(defn- attrs-of-tag [tag content]
	(map :attrs (filter #(= tag (:tag %)) content)))

(defn- bnd-lib-id [id capability-key]
	(str "feature_" id capability-key))

(defn- bnd-lib-filename [id version capability-key]
	(str (bnd-lib-id id capability-key) "-" (trim-build-segment version) ".lib"))

(defn- bnd-instruction [key value]
	(if (nil? value)
		""
		(str ";" key "=" value)))

(defn- to-bnd-entry [id version os ws arch nl]
	(-> id		
		(str (bnd-instruction "version" version))
		(str (bnd-instruction "os" os))
		(str (bnd-instruction "ws" ws))
		(str (bnd-instruction "arch" arch))
		(str (bnd-instruction "nl" nl))))

(defn- to-bnd-bundle-entry [plugin]
	(let [{:keys [id version os ws arch nl]} plugin
		  lib-id id
		  lib-version (trim-build-segment version)]
		  (to-bnd-entry lib-id lib-version os ws arch nl)))

(defn- to-bnd-lib-entry [feature]
	(let [{:keys [id version os ws arch nl]} feature
			lib-id (bnd-lib-id id "") ;XXX no capability-specific dependencies are foreseen yet
			lib-version (trim-build-segment version)]
		  (to-bnd-entry lib-id lib-version os ws arch nl)))

(defn- write-lib-file! [file feature-id feature-version entries]
	(with-open [writer (io/writer file)]
		(.write writer "############################################################\n")
		(.write writer "# BND lib file automatically generated by clojure.osgi.tools\n")
		(.write writer "# Source Eclipse feature:\n")
		(.write writer (str "# " feature-id "_" feature-version "\n"))
		(.write writer "############################################################\n")
		(doall (map #(.write writer (str % "\n")) entries))))

(defn- capability-entry [value]
	(if (or (nil? value) (= "*" value))
		""
		(str "-" value)))

(defn- capabilities-key [{:keys [os ws arch nl]}]
	(-> ""
		(str (capability-entry os))
		(str (capability-entry ws))
		(str (capability-entry arch))
		(str (capability-entry nl))))

(defn create-lib-from-pde-feature
	"Creates a BND property file 
	based on the given PDE feature.xml file
	in the given directory."
	[feature-xml out-dir]
	(log/trace "parsing" feature-xml)
	(let [
		xml (xml/parse feature-xml)
		
		feature (:attrs xml)
		id (:id feature)
		version (:version feature)

		content (:content xml)
		includes (attrs-of-tag :includes content)
		plugins (attrs-of-tag :plugin content)

		grouped-includes (group-by capabilities-key includes)
		grouped-plugins (group-by capabilities-key plugins)

		;contributed capabilities
		capabilities-contrib (concat (keys grouped-plugins) (keys grouped-includes))
		;capabilities to process: artificially include empties to get the file generated
		capabilities (if (empty? capabilities-contrib) [""] capabilities-contrib)

		;BND lib entries (rows), grouped by capability-key
		grouped-entries (reduce 
			#(assoc %1 %2 (concat 
				(map to-bnd-lib-entry (get grouped-includes %2))
				(map to-bnd-bundle-entry (get grouped-plugins %2))))
			{} 
			capabilities)]

			(map #(let [
				entries (get grouped-entries %)
				bnd-lib-id (bnd-lib-id id %)
				out-filename (bnd-lib-filename id version %)
				out-file (java.io.File. (str out-dir "/" bnd-lib-id "/" out-filename))
				 	]

				 	(log/debug "generating" out-filename)
					(.mkdirs (.getParentFile out-file))
					(write-lib-file! out-file id version entries)
					out-file)
			capabilities)))

		

(defn- find-files [dirpath pattern]
  (filter #(re-matches pattern (.getName %))
               (file-seq (java.io.File. dirpath))))

(defn- collect-feature-uris [dirpath]
	(let [unjared (find-files dirpath #"feature\.xml")
		jars (find-files dirpath #".+\.jar")
		jared (map #(str "jar:file:///" (.getAbsolutePath %) "!/feature.xml") jars)]
		(concat jared unjared)))

(defn create-libs-from-pde-features
	"Creates a BND lib property files based on
	the given directory with PDE features
	in the given directory for BND libs."
	[features-dir bnd-libs-dir]

	(let [feature-uris (collect-feature-uris features-dir)]
		(doall (map #(create-lib-from-pde-feature % bnd-libs-dir) feature-uris))))